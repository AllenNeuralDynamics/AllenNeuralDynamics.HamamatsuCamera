using HamamatsuCamera.API;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Drawing.Text;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using ZedGraph;

namespace HamamatsuCamera.Factories
{
    public class VisualizerFactory : IDisposable
    {
        private const double TargetElapsedTime = 1.0 / 40.0; // Update at approximately 40Hz
        private const int Capacity = 300;                       // Capacity of the plots
        private const float MinFontSize = 8.0f;
        private const int FillOpacity = 85;
        private const float Luminance = 0.5f;
        private const float LabelFontScale = 0.8f;
        private const double MaxImageScale = 50.0;
        private const double MinImageScale = 1.0;
        //private const int DisplayBPP = 3;
        private const double TargetPeriod = 0.025; // Millis
        private const int PenWidth = 10;

        private double StartTime = -1;
        private double PreviousUpdateTime = 0;
        private List<double> Timestamps;
        private List<List<double>> Values;
        private int NumSignals;
        // ---------------- Global Variables ----------------
        private Queue<Frame> FrameQueue = new Queue<Frame>();
        private bool bGenerate = true;      // Controls the disposal of this class
        private object Observer;            // Observer of converted frames generated by this factory

        // ---------------- Factory Construction && Public Methods ----------------

        /// <summary>
        /// Constructor that sets the observer
        /// </summary>
        /// <param name="imageObserver"></param>
        internal VisualizerFactory(object imageObserver)
        {
            SetObserver(imageObserver);
            Timestamps = new List<double>();
            Values = new List<List<double>>();
        }

        /// <summary>
        /// Sets the converted frame observer in this class and throws and exception if there is no observer
        /// </summary>
        /// <param name="observer">Observer created in the <see cref="ImageTypeVisualizer"/> class.</param>
        internal void SetObserver(object observer)
        {
            this.Observer = observer ?? throw new ArgumentNullException(nameof(observer));
        }

        /// <summary>
        /// Opens this <see cref="ImageVisualizerFactory"/> class by starting a new task factory
        /// with the <see cref="DataGenerator(object)"/> 
        /// </summary>
        public void Open()
        {
            Task.Factory.StartNew(new Action<object>(DataGenerator), Observer);
        }

        /// <summary>
        /// Stores un-processed <see cref="Frame"/> that enter the <see cref="ImageTypeVisualizer"/>
        /// class in a list until they are processed.
        /// </summary>
        /// <param name="newFrame">Un-processed <see cref="Frame"/> that entered the <see cref="ImageTypeVisualizer"/> class.</param>
        public void Write(Frame newFrame)
        {
            FrameQueue.Enqueue(newFrame);
        }

        /// <summary>
        /// Disposes this <see cref="ImageVisualizerFactory"/> class by allowing the <see cref="DataGenerator(object)"/>
        /// to gracefully exit.
        /// </summary>
        public void Dispose()
        {
            bGenerate = false;
        }

        /// <summary>
        /// Asynchronously processes new frames generated by the <see cref="C13440"/>
        /// classed passed through the <see cref="ImageTypeVisualizer"/> class.
        /// Converts the bit depth from Mono16 to Mono8 for display in a <see cref="ImageView"/>
        /// </summary>
        /// <param name="observer"><see cref="ConvertedFrame"/> observer created in the <see cref="ImageTypeVisualizer"/> class.</param>
        private void DataGenerator(object observer)
        {
            // Locally set the observer
            IObserver<VisualizerData> processObserver = (IObserver<VisualizerData>)observer;
            // Loop until factory is disposed by the ImageTypeVisualizer class, i.e. closing the visualizer
            while (bGenerate)
            {
                // If there is a new frame to process
                while (FrameQueue.Count > 0)
                {
                    // Access the oldest un-processed frame in the new frames list
                    Frame readFrame = FrameQueue.Dequeue();
                    if (readFrame == null || !readFrame.isValid() || readFrame.RegionData == null) continue;

                    if (StartTime < 0)
                    {
                        StartTime = readFrame.CameraTimestamp;
                        NumSignals = Math.Max(readFrame.DeinterleaveCount, 1);
                        foreach (var regionData in readFrame.RegionData)
                            Values.Add(new List<double>());
                    }

                    var output = new VisualizerData();

                    if (readFrame.CameraTimestamp - PreviousUpdateTime >= TargetElapsedTime)
                    {
                        output.Image = GenerateNewImage(readFrame);
                        DrawRegions(ref output, readFrame.Regions);
                        PreviousUpdateTime = readFrame.CameraTimestamp;
                    }
                    output.DeinterleaveCount = NumSignals;
                    output.CurrentSignal = readFrame.Framestamp % NumSignals;

                    Timestamps.Add(readFrame.CameraTimestamp);
                    while (Timestamps.Count > Capacity)
                        Timestamps.RemoveAt(0);
                    output.xMin = Timestamps[0] - StartTime;
                    output.xMax = Timestamps[Timestamps.Count - 1] - StartTime;

                    output.yMins = new List<double>();
                    output.yMaxes = new List<double>();
                    output.RegionData = new List<PointPair>();
                    for (int i = 0; i < readFrame.RegionData.Count; i++)
                    {
                        Values[i].Add(readFrame.RegionData[i]);
                        while (Values[i].Count > Capacity)
                            Values[i].RemoveAt(0);
                        output.yMins.Add(Values[i].Min());
                        output.yMaxes.Add(Values[i].Max());

                        output.RegionData.Add(new PointPair(readFrame.CameraTimestamp - StartTime, readFrame.RegionData[i]));
                    }
                    if(Timestamps.Count > 1)
                        output.FPS = Timestamps.Count / (Timestamps[Timestamps.Count - 1] - Timestamps[0]);
                    
                    processObserver.OnNext(output);
                }

                // Wait until there is a new frame to process
                Thread.Sleep(1);
            }
            //Console.WriteLine("Disposed");
        }

        private Bitmap GenerateNewImage(Frame frame)
        {
            unsafe
            {
                Bitmap dispImg = new Bitmap(frame.Width, frame.Height, PixelFormat.Format24bppRgb);
                BitmapData dispImg_bitmapData = dispImg.LockBits(new Rectangle(0, 0, frame.Width, frame.Height), ImageLockMode.WriteOnly, dispImg.PixelFormat);

                if(frame.PixelType == DCAM_PIXELTYPE.MONO8)
                {
                    int frame_widthInBytes = frame.Width;
                    int dispImg_widthInBytes = 3 * frame.Width;

                    byte* frame_ptrFirstPixel = (byte*)frame.bufframe.buf;
                    byte* dispImg_ptrFirstPixel = (byte*)dispImg_bitmapData.Scan0;

                    Parallel.For(0, frame.Height, y =>
                    {
                        byte* frame_ptrCurrPixel = frame_ptrFirstPixel + y * frame_widthInBytes;
                        byte* dispImg_ptrCurrPixel = dispImg_ptrFirstPixel + y * dispImg_widthInBytes;
                        byte* frame_ptrLastPixel = frame_ptrCurrPixel + frame_widthInBytes;
                        while(frame_ptrCurrPixel < frame_ptrLastPixel)
                        {
                            var MSB = (byte)(frame.LookupTable[*(frame_ptrCurrPixel++)]);
                            dispImg_ptrCurrPixel[0] = MSB;
                            dispImg_ptrCurrPixel[1] = MSB;
                            dispImg_ptrCurrPixel[2] = MSB;
                            dispImg_ptrCurrPixel += 3; 
                        }
                    });
                }
                else if (frame.PixelType == DCAM_PIXELTYPE.MONO16)
                {
                    int frame_widthInUshorts = frame.Width;
                    int dispImg_widthInBytes = 3 * frame.Width;

                    ushort* frame_ptrFirstPixel = (ushort*)frame.bufframe.buf;
                    byte* dispImg_ptrFirstPixel = (byte*)dispImg_bitmapData.Scan0;

                    Parallel.For(0, frame.Height, y =>
                    {
                        ushort* frame_ptrCurrPixel = frame_ptrFirstPixel + y * frame_widthInUshorts;
                        byte* dispImg_ptrCurrPixel = dispImg_ptrFirstPixel + y * dispImg_widthInBytes;
                        ushort* frame_ptrLastPixel = frame_ptrCurrPixel + frame_widthInUshorts;
                        while (frame_ptrCurrPixel < frame_ptrLastPixel)
                        {
                            var MSB = (byte)(frame.LookupTable[*(frame_ptrCurrPixel++)]>>8);
                            dispImg_ptrCurrPixel[0] = MSB;
                            dispImg_ptrCurrPixel[1] = MSB;
                            dispImg_ptrCurrPixel[2] = MSB;
                            dispImg_ptrCurrPixel += 3;
                        }
                    });
                }
                dispImg.UnlockBits(dispImg_bitmapData);


                return dispImg;
            }


        }
        private void DrawRegions(ref VisualizerData data, List<Rectangle> regions)
        {
            try
            {
                // Using graphics, draw rectangles and labels over the image where the regions are located. Use a different pen for the selected region if one exists
                using (var graphics = Graphics.FromImage(data.Image))
                using (var nonSelectedRegionPen = new Pen(Color.FromArgb(Color.Red.A, (int)(Color.Red.R * Luminance), (int)(Color.Red.G * Luminance), (int)(Color.Red.B * Luminance)), PenWidth))
                using (var selectedRegionPen = new Pen(Color.FromArgb(Color.Yellow.A, (int)(Color.Yellow.R * Luminance), (int)(Color.Yellow.G * Luminance), (int)(Color.Yellow.B * Luminance)), PenWidth))
                using (var cropPen = new Pen(Color.Green, PenWidth))
                using (var format = new StringFormat())
                {
                    graphics.TextRenderingHint = TextRenderingHint.AntiAliasGridFit;
                    graphics.SmoothingMode = SmoothingMode.AntiAlias;
                    format.Alignment = StringAlignment.Center;
                    format.LineAlignment = StringAlignment.Center;
                    // For each region
                    for (int i = 0; i < regions.Count; i++)
                    {
                        var rect = regions[i];
                        var regionPen = nonSelectedRegionPen;
                        var fontSize = Math.Max(Math.Min(rect.Height * LabelFontScale,
                                                rect.Width * LabelFontScale), MinFontSize);
                        var labelFont = new Font("Arial", fontSize, FontStyle.Regular);

                        graphics.DrawRectangle(regionPen, rect);
                        graphics.DrawString(i.ToString(), labelFont, Brushes.White, rect, format);
                        // Draw the rectangle and label it with the region index
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: DrawRegions\nMessage: {ex.Message}");
            }
        }
    }
}
