using Bonsai.IO;
using HamamatsuCamera.API;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace HamamatsuCamera.Factories
{
    /// <summary>
    /// Asynchronously generates a sequence of <see cref="ImageData"/>.
    /// Accepts <see cref="Frame"/> data using the <see cref="Write(Frame)"/> method
    /// and stores the data in <see cref="NewFrames"/> until it is processed by the
    /// <see cref="DataGenerator(object)"/> method asynchronously.
    /// 
    /// Writes the processed data to a user-specified .csv file.
    /// </summary>
    public class ProcessingFactory : IDisposable
    {
        // ---------------- Global Constants ----------------

        private const int MetaDataOffset = 9;           // Number of columns of MetaData in the output .csv file
        private const string ListSeparator = ",";       // List separator for writing to different columns of a .csv file
        private const string RegionLabel = "Region ";   // Base column header for region data, combined with region index

        // ---------------- Global Variables ----------------

        private Queue<Frame> FrameQueue = new Queue<Frame>();  // Stores un-processed frames in a Queue until they are processed

        // Output .csv file generation
        private StreamWriter runningWriter; // Writer for writing to .csv file
        private byte DeinterleaveCount;     // Used in ImageProcessingView to deinterleave region activity into a user-specified number of signals
        private string FileName;            // File name of the .csv file being written to
        private PathSuffix Suffix;          // Suffix of the file name of the .csv file being written to
        private bool Overwrite;             // Flag for whether to overwrite the .csv file if it exists

        private List<Rectangle> Regions;


        // Flags that control the processing of camera frames
        private bool bGenerate = true;      // Controls the disposal of this class
        private bool firstFrame = true;

        // Observer of image data generated by this factory
        private object Observer;

        private Dictionary<int, int> LookupTable;

        // ---------------- Factory Construction && Public Methods ----------------

        /// <summary>
        /// Constructor that sets the observer and stores the user-defined properties
        /// from the <see cref="ImageProcessing"/> class.
        /// Creates the .csv writer.
        /// </summary>
        /// <param name="frameObserver">Observer created in the <see cref="ImageProcessing"/> class.</param>
        /// <param name="imageProcessing">Access to the user-defined properties of the <see cref="ImageProcessing"/> class.</param>
        internal ProcessingFactory(object frameObserver, ImageProcessing imageProcessing)
        {
            SetObserver(frameObserver);
            DeinterleaveCount = imageProcessing.DeinterleaveCount;
            FileName = imageProcessing.FileName;
            Suffix = imageProcessing.Suffix;
            Overwrite = imageProcessing.Overwrite;
            LookupTable = new Dictionary<int, int>();
            for(int i = 0; i <= ushort.MaxValue; i++)
            {
                LookupTable[i] = i;
            }
            CreateWriter();
        }

        /// <summary>
        /// Sets the frame observer in this class and throws and exception if there is no observer
        /// </summary>
        /// <param name="observer">Observer created in the <see cref="ImageProcessing"/> class.</param>
        internal void SetObserver(object observer)
        {
            this.Observer = observer ?? throw new ArgumentNullException(nameof(observer));
        }

        /// <summary>
        /// Opens this <see cref="ImageProcessingFactory"/> class by starting a new task factory
        /// with the <see cref="DataGenerator(object)"/> 
        /// </summary>
        public void Open()
        {
            Task.Factory.StartNew(new Action<object>(DataGenerator), Observer);
        }

        /// <summary>
        /// Stores un-processed <see cref="Frame"/> that enter the <see cref="ImageProcessing"/>
        /// class in a list until they are processed.
        /// </summary>
        /// <param name="newFrame">Un-processed <see cref="Frame"/> that entered the <see cref="ImageProcessing"/> class.</param>
        public void Write(Frame newFrame)
        {
            FrameQueue.Enqueue(newFrame);
        }

        /// <summary>
        /// Disposes this <see cref="ImageProcessingFactory"/> class by allowing the <see cref="DataGenerator(object)"/>
        /// to gracefully exit.
        /// </summary>
        public void Dispose()
        {
            bGenerate = false;
        }

        // ----------------- CSV Writing ----------------

        /// <summary>
        /// Creates the .csv writer and writes the header row to file.
        /// </summary>
        private void CreateWriter()
        {
            // Verify a valid file path exists
            var fileName = FileName;
            if (string.IsNullOrEmpty(fileName))
                throw new InvalidOperationException("A valid file path must be specified.");

            // Ensure the directory exists and append the user-defined suffix
            PathHelper.EnsureDirectory(fileName);
            fileName = PathHelper.AppendSuffix(fileName, Suffix);

            // Verify that if the file already exists, the user gave permission to overwrite it.
            if (File.Exists(fileName) && !Overwrite)
                throw new IOException(string.Format("The file '{0}' already exists.", fileName));

            // Create .csv writer
            runningWriter = new StreamWriter(fileName, false, Encoding.ASCII);

            var columns = new List<string>(MetaDataOffset);
            columns.Add(nameof(Frame.Width));
            columns.Add(nameof(Frame.Height));
            columns.Add(nameof(Frame.Left));
            columns.Add(nameof(Frame.Top));
            columns.Add(nameof(Frame.Framestamp));
            columns.Add(nameof(Frame.ComputerTimestamp));
            columns.Add(nameof(Frame.CameraTimestamp));


            var header = string.Join(ListSeparator, columns);
            runningWriter.Write(header);
        }

        /// <summary>
        /// Called once after the first <see cref="Frame"/> was processed.
        /// Writes the column headers for the regions since we now know how many
        /// the user specified.
        /// </summary>
        /// <param name="newFrame">First processed frame.</param>
        private void AddROIColumns()
        {
            var columns = new List<string>(Regions.Count * 2);
            for (int i = 0; i < Regions.Count; i++)
            {
                columns.Add(RegionLabel + i);
            }
            for (int i = 0; i < Regions.Count; i++)
            {
                columns.Add(RegionLabel + i + " With LUT");
            }
            var header = string.Join(ListSeparator, columns);
            runningWriter.WriteLine(ListSeparator + header);
        }

        /// <summary>
        /// Writes the processed frame to the next row of the .csv file.
        /// </summary>
        /// <param name="newFrame">Processed <see cref="Frame"/>.</param>
        private void WriteOutput(FrameData newFrame, Frame frame)
        {
            var activity = newFrame.RegionData;
            var lutActivity = newFrame.TransformedRegionData;
            var values = new List<string>(activity.Length + MetaDataOffset);
            values.Add(frame.Width.ToString(CultureInfo.InvariantCulture));
            values.Add(frame.Height.ToString(CultureInfo.InvariantCulture));
            values.Add(frame.Left.ToString(CultureInfo.InvariantCulture));
            values.Add(frame.Top.ToString(CultureInfo.InvariantCulture));
            values.Add(frame.Framestamp.ToString(CultureInfo.InvariantCulture));
            values.Add(frame.ComputerTimestamp.ToString(CultureInfo.InvariantCulture));
            values.Add(frame.CameraTimestamp.ToString(CultureInfo.InvariantCulture));
            for (int i = 0; i < activity.Length; i++)
            {
                values.Add(activity[i].ToString(CultureInfo.InvariantCulture));
            }
            for (int i = 0; i < lutActivity.Length; i++)
            {
                values.Add(lutActivity[i].ToString(CultureInfo.InvariantCulture));
            }

            var line = string.Join(ListSeparator, values);
            runningWriter.WriteLine(line);
        }

        // ----------------- Frame Processing ----------------
        Stopwatch stopwatch = new Stopwatch();
        /// <summary>
        /// Asynchronously processes <see cref="Frame"/> entering from the <see cref="ImageProcessing"/> class.
        /// Writes the processed frame of type <see cref="ImageData"/> to a .csv file.
        /// Passes the <see cref="ImageData"/> to an observable sequence for use in the
        /// <see cref="ImageProcessingVisualizer"/>.
        /// </summary>
        /// <param name="observer">The <see cref="ImageData"/> observer created within the <see cref="ImageProcessing"/> class.</param>
        private void DataGenerator(object observer)
        {
            // Locally set the observer
            IObserver<FrameData> processObserver = (IObserver<FrameData>)observer;

            // Loop until factory is disposed by the ImageProcessing class, i.e. stopping the Bonsai workflow
            while (bGenerate)
            {
                while(FrameQueue.Count != 0)
                {
                    Frame frame = FrameQueue.Dequeue();

                    if (frame.isValid())
                    {
                        // For the first frame, initialize the Regions and Add ROI Columns
                        if (firstFrame)
                        {

                            Regions = (frame.Regions == null || frame.Regions.Count == 0) ? new List<Rectangle>() { new Rectangle(frame.Left, frame.Top, frame.Width, frame.Height) } : frame.Regions;
                            AddROIColumns();
                            firstFrame = false;
                            if (frame.LookupTable != null)
                                LookupTable = frame.LookupTable;
                        }

                        FrameData output = new FrameData();
                        output.DeinterleaveCount = DeinterleaveCount;
                        output.CameraTimestamp = frame.CameraTimestamp;
                        output.Framestamp = frame.Framestamp;

                        if (frame.PixelType == DCAM_PIXELTYPE.MONO8)
                        {
                            var processedData = ProcessMono8(frame);
                            output.RegionData = processedData[0];
                            output.TransformedRegionData = processedData[1];
                        }
                        else if (frame.PixelType == DCAM_PIXELTYPE.MONO16)
                        {
                            var processedData = ProcessMono16(frame);
                            output.RegionData = processedData[0];
                            output.TransformedRegionData = processedData[1];
                        }

                        // Write the processed frame to .csv
                        WriteOutput(output, frame);

                        // Output the processed frame to the observable sequence for use in the FrameDataVisualizer
                        processObserver.OnNext(output);
                    }
                    
                }
                
                // Wait until there is a new frame to process
                Thread.Sleep(1);
            }

            // When disposed close the .csv writer.
            if (runningWriter != null)
                runningWriter.Close();
        }

        private double[][] ProcessMono16(Frame frame)
        {
            unsafe
            {
                ushort* img_ptrFirstPixel = (ushort*)frame.bufframe.buf;

                double[][] output = new double[2][];
                output[0] = new double[Regions.Count];
                output[1] = new double[Regions.Count];
                for (int i = 0; i < Regions.Count; i++)
                {
                    var region = Regions[i];
                    int reg_widthInPixels = region.Width;
                    int reg_heightInPixels = region.Height;
                    int reg_offsetInPixels = Math.Max(0, (region.Y - frame.Top)) * frame.Width + Math.Max(0,(region.X - frame.Left));
                    ushort* reg_ptrFirstPixel = img_ptrFirstPixel + reg_offsetInPixels;

                    double[] rowSums = new double[reg_heightInPixels];
                    double[] transformedRowSums = new double[reg_heightInPixels];
                    double numRows = reg_heightInPixels;

                    // Parallel process each row of pixels contained in the region
                    Parallel.For(0, reg_heightInPixels, y =>
                    {
                        // Offset to first pixel of row in image
                        int row_offsetInPixels = frame.Width * y;

                        // Pointer to first pixel of the row in the image that is contained in the region
                        ushort* row_ptrFirstPixel = reg_ptrFirstPixel + row_offsetInPixels;

                        // Loop through all of the pixels of the image row contained in the region
                        for (int x = 0; x < reg_widthInPixels; x++)
                        {
                            // Add to total sum of the row
                            rowSums[y] += row_ptrFirstPixel[x];
                            transformedRowSums[y] += LookupTable[row_ptrFirstPixel[x]];
                        }
                    });

                    output[0][i] = rowSums.Average() / (double)reg_widthInPixels;
                    output[1][i] = transformedRowSums.Average() / (double)reg_widthInPixels;
                }

                return output;
            }
        }

        private double[][] ProcessMono8(Frame frame)
        {
            unsafe
            {
                byte* img_ptrFirstPixel = (byte*)frame.bufframe.buf;
                int img_widthInBytes = frame.bufframe.rowbytes;
                double[][] output = new double[2][];
                output[0] = new double[Regions.Count];
                output[1] = new double[Regions.Count];
                for (int i = 0; i < Regions.Count; i++)
                {
                    var region = Regions[i];
                    int reg_widthInPixels = region.Width;
                    int reg_heightInPixels = region.Height;
                    int reg_offsetInBytes = Math.Max(0, (region.Y - frame.Top)) * frame.Width + Math.Max(0, (region.X - frame.Left));
                    byte * reg_ptrFirstPixel = img_ptrFirstPixel + reg_offsetInBytes;

                    double[] rowSums = new double[reg_heightInPixels];
                    double[] transformedRowSums = new double[reg_heightInPixels];
                    double numRows = reg_heightInPixels;

                    // Parallel process each row of pixels contained in the region
                    Parallel.For(0, reg_heightInPixels, y =>
                    {
                        // Offset to first pixel of row in image
                        int row_offsetInBytes = img_widthInBytes * y;

                        // Pointer to first pixel of the row in the image that is contained in the region
                        byte* row_ptrFirstPixel = reg_ptrFirstPixel + row_offsetInBytes;

                        // Loop through all of the pixels of the image row contained in the region
                        for (int x = 0; x < reg_widthInPixels; x++)
                        {
                            // Add to total sum of the row
                            rowSums[y] += row_ptrFirstPixel[x];
                            transformedRowSums[y] += LookupTable[row_ptrFirstPixel[x]];
                        }
                    });

                    output[0][i] = rowSums.Average() / (double)reg_widthInPixels;
                    output[1][i] = transformedRowSums.Average() / (double)reg_widthInPixels;
                }

                return output;
            }
        }
    }
}
